## std::set 和 std::unordered_set
`std::set` 和 `std::unordered_set` 是 C++ 标准库中提供的两种集合容器，它们的主要功能是存储一组唯一的元素，同时提供高效的插入、删除和查找操作。然而，它们的实现方式和特点有显著不同。

---

### 1. **`std::set`**
- **实现方式**：基于 **红黑树**（自平衡二叉搜索树）。
- **特点**：
  1. **有序性**：元素按照键值从小到大的顺序自动排序。
  2. **时间复杂度**：
     - 插入、删除、查找操作的时间复杂度为 \( O(\log n) \)。
  3. **支持迭代器顺序遍历**：遍历时按照元素的顺序。
  4. **占用内存较少**：没有额外的哈希表开销。

- **适用场景**：
  - 当需要保持元素的顺序。
  - 需要频繁遍历集合中的元素。

- **示例代码**：
  ```cpp
  #include <iostream>
  #include <set>

  int main() {
      std::set<int> s;
      s.insert(5);
      s.insert(1);
      s.insert(3);

      for (int x : s) {
          std::cout << x << " "; // 输出：1 3 5
      }

      return 0;
  }
  ```

---

### 2. **`std::unordered_set`**
- **实现方式**：基于 **哈希表**。
- **特点**：
  1. **无序性**：元素存储顺序与插入顺序无关。
  2. **时间复杂度**：
     - 插入、删除、查找操作的平均时间复杂度为 \( O(1) \)。
     - 在最坏情况下（哈希冲突严重）复杂度为 \( O(n) \)。
  3. **哈希表开销**：需要额外的内存存储哈希表。
  4. **自定义哈希函数**：支持通过 `std::hash` 或用户自定义哈希函数扩展。

- **适用场景**：
  - 不关心元素顺序。
  - 需要高效的插入、删除、查找操作。

- **示例代码**：
  ```cpp
  #include <iostream>
  #include <unordered_set>

  int main() {
      std::unordered_set<int> us;
      us.insert(5);
      us.insert(1);
      us.insert(3);

      for (int x : us) {
          std::cout << x << " "; // 输出顺序可能是：3 1 5（无序）
      }

      return 0;
  }
  ```

---

### 3. **`std::set` vs `std::unordered_set`**
| 特性                | `std::set`                       | `std::unordered_set`           |
|---------------------|----------------------------------|---------------------------------|
| **底层实现**         | 红黑树                           | 哈希表                          |
| **有序性**           | 元素按顺序存储                   | 元素存储无序                   |
| **插入/删除/查找**    | \( O(\log n) \)                  | 平均 \( O(1) \)，最坏 \( O(n) \) |
| **内存开销**         | 较小                             | 较大（需存储哈希表）            |
| **遍历顺序**         | 按元素顺序                       | 无序                           |
| **适用场景**         | 需要有序集合                     | 需要快速查找                   |

---

### 4. **选择指南**
- 使用 `std::set`：
  - 当需要按顺序访问元素时（如在排序后进行操作）。
  - 对内存使用有严格要求。

- 使用 `std::unordered_set`：
  - 当对性能要求较高，且不需要有序存储。
  - 数据较大且查找频繁。

---

### 总结
- **`std::set`** 保持有序，适用于需要顺序的场景，操作复杂度为 \( O(\log n) \)。
- **`std::unordered_set`** 高效但无序，适用于追求操作速度的场景，平均复杂度为 \( O(1) \)。